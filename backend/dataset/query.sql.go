// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package dataset

import (
	"context"
	"database/sql"
)

const getAverageReviewScoreOverTime = `-- name: GetAverageReviewScoreOverTime :many
SELECT 
  strftime('%Y-%m', review_creation_date) AS month, 
  AVG(review_score) AS average_review_score
FROM 
  order_reviews
GROUP BY 
  month
ORDER BY 
  month
`

type GetAverageReviewScoreOverTimeRow struct {
	Month              interface{}
	AverageReviewScore sql.NullFloat64
}

func (q *Queries) GetAverageReviewScoreOverTime(ctx context.Context) ([]GetAverageReviewScoreOverTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getAverageReviewScoreOverTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAverageReviewScoreOverTimeRow
	for rows.Next() {
		var i GetAverageReviewScoreOverTimeRow
		if err := rows.Scan(&i.Month, &i.AverageReviewScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerDistributionByState = `-- name: GetCustomerDistributionByState :many
SELECT 
  customer_state, 
  COUNT(*) AS customer_count
FROM 
  customers
GROUP BY 
  customer_state
`

type GetCustomerDistributionByStateRow struct {
	CustomerState sql.NullString
	CustomerCount int64
}

func (q *Queries) GetCustomerDistributionByState(ctx context.Context) ([]GetCustomerDistributionByStateRow, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerDistributionByState)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomerDistributionByStateRow
	for rows.Next() {
		var i GetCustomerDistributionByStateRow
		if err := rows.Scan(&i.CustomerState, &i.CustomerCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstallmentsUsage = `-- name: GetInstallmentsUsage :many
SELECT 
  payment_installments, 
  COUNT(*) AS installment_count
FROM 
  order_payments
GROUP BY 
  payment_installments
ORDER BY 
  payment_installments
`

type GetInstallmentsUsageRow struct {
	PaymentInstallments sql.NullInt64
	InstallmentCount    int64
}

func (q *Queries) GetInstallmentsUsage(ctx context.Context) ([]GetInstallmentsUsageRow, error) {
	rows, err := q.db.QueryContext(ctx, getInstallmentsUsage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInstallmentsUsageRow
	for rows.Next() {
		var i GetInstallmentsUsageRow
		if err := rows.Scan(&i.PaymentInstallments, &i.InstallmentCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentMethodsDistribution = `-- name: GetPaymentMethodsDistribution :many
SELECT 
  payment_type, 
  COUNT(*) AS payment_count
FROM 
  order_payments
GROUP BY 
  payment_type
ORDER BY 
  payment_count DESC
`

type GetPaymentMethodsDistributionRow struct {
	PaymentType  sql.NullString
	PaymentCount int64
}

func (q *Queries) GetPaymentMethodsDistribution(ctx context.Context) ([]GetPaymentMethodsDistributionRow, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentMethodsDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaymentMethodsDistributionRow
	for rows.Next() {
		var i GetPaymentMethodsDistributionRow
		if err := rows.Scan(&i.PaymentType, &i.PaymentCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewScoreDistribution = `-- name: GetReviewScoreDistribution :many
SELECT 
  review_score, 
  COUNT(*) AS review_count
FROM 
  order_reviews
GROUP BY 
  review_score
ORDER BY 
  review_score
`

type GetReviewScoreDistributionRow struct {
	ReviewScore sql.NullInt64
	ReviewCount int64
}

func (q *Queries) GetReviewScoreDistribution(ctx context.Context) ([]GetReviewScoreDistributionRow, error) {
	rows, err := q.db.QueryContext(ctx, getReviewScoreDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewScoreDistributionRow
	for rows.Next() {
		var i GetReviewScoreDistributionRow
		if err := rows.Scan(&i.ReviewScore, &i.ReviewCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesByCategory = `-- name: GetSalesByCategory :many
SELECT 
  pcn.product_category_name_english, 
  SUM(oi.price) AS total_sales
FROM 
  order_items oi
JOIN 
  products p ON oi.product_id = p.product_id
JOIN 
  product_category_name_translation pcn ON p.product_category_name = pcn.product_category_name
GROUP BY 
  pcn.product_category_name_english
ORDER BY 
  total_sales DESC
`

type GetSalesByCategoryRow struct {
	ProductCategoryNameEnglish sql.NullString
	TotalSales                 sql.NullFloat64
}

func (q *Queries) GetSalesByCategory(ctx context.Context) ([]GetSalesByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getSalesByCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesByCategoryRow
	for rows.Next() {
		var i GetSalesByCategoryRow
		if err := rows.Scan(&i.ProductCategoryNameEnglish, &i.TotalSales); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSellersBySales = `-- name: GetTopSellersBySales :many
SELECT 
  s.seller_id, 
  SUM(oi.price) AS total_sales
FROM 
  order_items oi
JOIN 
  sellers s ON oi.seller_id = s.seller_id
GROUP BY 
  s.seller_id
ORDER BY 
  total_sales DESC
LIMIT 10
`

type GetTopSellersBySalesRow struct {
	SellerID   sql.NullString
	TotalSales sql.NullFloat64
}

func (q *Queries) GetTopSellersBySales(ctx context.Context) ([]GetTopSellersBySalesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSellersBySales)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellersBySalesRow
	for rows.Next() {
		var i GetTopSellersBySalesRow
		if err := rows.Scan(&i.SellerID, &i.TotalSales); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalSalesOverTime = `-- name: GetTotalSalesOverTime :many
SELECT 
  strftime('%Y-%m', order_purchase_timestamp) AS month, 
  SUM(oi.price) AS total_sales
FROM 
  orders o
JOIN 
  order_items oi ON o.order_id = oi.order_id
GROUP BY 
  month
ORDER BY 
  month
`

type GetTotalSalesOverTimeRow struct {
	Month      interface{}
	TotalSales sql.NullFloat64
}

func (q *Queries) GetTotalSalesOverTime(ctx context.Context) ([]GetTotalSalesOverTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getTotalSalesOverTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalSalesOverTimeRow
	for rows.Next() {
		var i GetTotalSalesOverTimeRow
		if err := rows.Scan(&i.Month, &i.TotalSales); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
